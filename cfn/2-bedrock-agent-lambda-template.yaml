AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template to create an AWS Bedrock Agent resource and Lambda function

Parameters:
  FoundationModel:
    Type: String
    Default: 'anthropic.claude-3-haiku-20240307-v1:0'
    Description: 'Foundation model ID. Using Claude 3 Haiku (Claude 3.7 Sonnet has tool name validation issues)'
  Alias:
    Type: String
    Default: '{ENTER ALIAS}'
  AthenaDatabaseName:
    Type: String
    Default: 'athena_db'
    Description: 'Base name of the Athena database (will be prefixed with the Alias)'
  AliasDb:
    Type: String
    Default: '{ENTER ALIAS DB}'
    Description: 'Sanitized alias (underscores only) used for Athena database names.'

Resources:
  AthenaQueryLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonAthenaFullAccess
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - !Ref CloudWatchLogsPolicy

  CloudWatchLogsPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*"

  BedrockAgentExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
        - !Ref LambdaInvokePolicy

  LambdaInvokePolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'lambda:InvokeFunction'
            Resource: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:AthenaQueryLambda-${Alias}-${AWS::Region}-${AWS::AccountId}'

  AthenaQueryLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub 'AthenaQueryLambda-${Alias}-${AWS::Region}-${AWS::AccountId}'
      Handler: index.lambda_handler
      Role: !GetAtt AthenaQueryLambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 1024
      Timeout: 120
      #ReservedConcurrentExecutions: 2  # Set to your desired number
      Environment:
        Variables:
          S3Output: !Sub "s3://sl-athena-output-${Alias}-${AWS::AccountId}-${AWS::Region}/"
          DatabaseName: !Sub "${AliasDb}_${AthenaDatabaseName}"
      Code:
        ZipFile: |
          import boto3
          from time import sleep
          import os
          import logging

          # Initialize the Athena client
          athena_client = boto3.client('athena')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"Received event: {event}")

              def athena_query_handler(event):
                  try:
                      # Extracting the SQL query
                      query = event['requestBody']['content']['application/json']['properties'][0]['value']
                      
                      # Handle empty query (e.g., when user just says "Hi")
                      if not query or query.strip() == '':
                          logger.info("Empty query received - returning friendly message")
                          return {
                              'ResultSet': {
                                  'Rows': [
                                      {'Data': [{'VarCharValue': 'Hello! I can help you query the database. Try asking something like: "How many records are there?" or "Show me 5 incident reports"'}]}
                                  ]
                              }
                          }
                      
                      logger.info(f"Executing query: {query}")

                      s3_output = os.environ.get('S3Output')
                      if not s3_output:
                          raise Exception("S3Output environment variable is not set")

                      # Execute the query and wait for completion
                      execution_id = execute_athena_query(query, s3_output)
                      result = get_query_results(execution_id)

                      return result

                  except Exception as e:
                      logger.error(f"Error in athena_query_handler: {str(e)}")
                      raise

              def execute_athena_query(query, s3_output):
                  try:
                      database_name = os.environ.get('DatabaseName')
                      query_execution_params = {
                          'QueryString': query,
                          'ResultConfiguration': {'OutputLocation': s3_output}
                      }
                      
                      # Add QueryExecutionContext if database name is set
                      if database_name:
                          query_execution_params['QueryExecutionContext'] = {'Database': database_name}
                          logger.info(f"Using database: {database_name}")
                      
                      response = athena_client.start_query_execution(**query_execution_params)
                      return response['QueryExecutionId']
                  except Exception as e:
                      logger.error(f"Failed to start query execution: {str(e)}")
                      raise

              def check_query_status(execution_id):
                  try:
                      response = athena_client.get_query_execution(QueryExecutionId=execution_id)
                      return response['QueryExecution']['Status']['State']
                  except Exception as e:
                      logger.error(f"Failed to check query status: {str(e)}")
                      raise

              def get_query_results(execution_id):
                  try:
                      while True:
                          status = check_query_status(execution_id)
                          if status in ['SUCCEEDED', 'FAILED', 'CANCELLED']:
                              break
                          sleep(1)  # Polling interval

                      if status == 'SUCCEEDED':
                          return athena_client.get_query_results(QueryExecutionId=execution_id)
                      else:
                          logger.error(f"Query failed with status '{status}'")
                          raise Exception(f"Query failed with status '{status}'")
                  except Exception as e:
                      logger.error(f"Failed to get query results: {str(e)}")
                      raise

              try:
                  action_group = event.get('actionGroup')
                  api_path = event.get('apiPath')

                  logger.info(f"api_path: {api_path}")

                  result = ''
                  response_code = 200

                  if api_path == '/athenaQuery':
                      result = athena_query_handler(event)
                  else:
                      response_code = 404
                      result = {"error": f"Unrecognized api path: {action_group}::{api_path}"}

                  response_body = {
                      'application/json': {
                          'body': result
                      }
                  }

                  action_response = {
                      'actionGroup': action_group,
                      'apiPath': api_path,
                      'httpMethod': event.get('httpMethod'),
                      'httpStatusCode': response_code,
                      'responseBody': response_body
                  }

                  api_response = {'messageVersion': '1.0', 'response': action_response}
                  return api_response

              except Exception as e:
                  logger.error(f"Unhandled exception: {str(e)}")
                  raise

  LambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: AthenaQueryLambda
    Properties:
      FunctionName: !GetAtt AthenaQueryLambda.Arn
      Action: 'lambda:InvokeFunction'
      Principal: 'bedrock.amazonaws.com'
      SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'

  BedrockAgent:
    Type: "AWS::Bedrock::Agent"
    DependsOn: LambdaInvokePermission
    Properties:
      AgentName: !Sub 'AthenaAgent-${Alias}-${AWS::Region}-${AWS::AccountId}'
      AgentResourceRoleArn: !GetAtt BedrockAgentExecutionRole.Arn
      AutoPrepare: 'True'
      FoundationModel: !Ref FoundationModel
      Instruction: |
        You are a SQL analyst that creates and EXECUTES queries for Amazon Athena.
        
        CRITICAL DECISION LOGIC:
        1. IF user is GREETING you (Hi, Hello, Hey, How are you) → Respond friendly WITHOUT calling any function
        2. IF user asks for DATA or information from database → Generate SQL and call athenaQuery function
        3. NEVER use placeholder table names like "your_table_name"
        
        Database: txt2sql_dev_athena_db
        Available tables: test_population (7867 records), txt2sql_dev_customers, txt2sql_dev_procedures
        
        WHEN TO QUERY VS WHEN TO RESPOND:
        - Greetings → Just respond: "Hello! I can help you query the database."
        - Data questions → Call athenaQuery with real table names
        
        Guidelines:
        - Decide first: Does this need database data? If NO, just respond
        - Use actual table names (test_population NOT your_table_name)
        - SELECT specific columns, avoid SELECT *
      ActionGroups:
        - ActionGroupName: query-athena
          ActionGroupExecutor:
            Lambda: !GetAtt AthenaQueryLambda.Arn
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.1",
                "info": {
                  "title": "AthenaQuery API",
                  "description": "API for querying txt2sql_dev_athena_db database. Available tables: test_population (7867 EMIR financial records), txt2sql_dev_customers, txt2sql_dev_procedures. ALWAYS use these exact table names.",
                  "version": "1.0.0"
                },
                "paths": {
                  "/athenaQuery": {
                    "post": {
                      "description": "Execute a SQL query on the Athena database. Use real table names: test_population, txt2sql_dev_customers, txt2sql_dev_procedures. NEVER use placeholder names like 'your_table_name' or 'table_name'.",
                      "requestBody": {
                        "description": "SQL query to execute on txt2sql_dev_athena_db database",
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "Query": {
                                  "type": "string",
                                  "description": "SQL query using real table names (test_population, txt2sql_dev_customers, txt2sql_dev_procedures). Example: SELECT COUNT(*) FROM test_population"
                                }
                              }
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response with query results",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "ResultSet": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "description": "A single row of query results"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

  BedrockAgentAlias:
    Type: 'AWS::Bedrock::AgentAlias'
    DependsOn: BedrockAgent
    Properties:
      AgentAliasName: !Sub '${Alias}-${AWS::Region}-alias'
      AgentId: !GetAtt BedrockAgent.AgentId

Outputs:
  BedrockAgentName:
    Description: 'Name of the Bedrock Agent created'
    Value: !Ref BedrockAgent
  AgentId:
    Description: 'ID of the Bedrock Agent'
    Value: !Ref BedrockAgent
  AgentAliasId:
    Description: 'ID of the Bedrock Agent Alias'
    Value: !Select [1, !Split ["|", !Ref BedrockAgentAlias]]
  AthenaQueryLambdaArn:
    Description: 'ARN of the Athena Query Lambda function'
    Value: !GetAtt AthenaQueryLambda.Arn