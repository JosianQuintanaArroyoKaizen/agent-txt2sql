AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template to create an AWS Bedrock Agent resource and Lambda function

Parameters:
  FoundationModel:
    Type: String
    Default: 'anthropic.claude-3-5-sonnet-20240620-v1:0'
    Description: 'Foundation model ID. Using Claude 3.5 Sonnet for better SQL generation and reasoning'
  Alias:
    Type: String
    Default: '{ENTER ALIAS}'
  AthenaDatabaseName:
    Type: String
    Default: 'athena_db'
    Description: 'Base name of the Athena database (will be prefixed with the Alias)'
  AliasDb:
    Type: String
    Default: '{ENTER ALIAS DB}'
    Description: 'Sanitized alias (underscores only) used for Athena database names.'

Resources:
  AthenaQueryLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonAthenaFullAccess
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - !Ref CloudWatchLogsPolicy

  CloudWatchLogsPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*"

  BedrockAgentExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
        - !Ref LambdaInvokePolicy

  LambdaInvokePolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'lambda:InvokeFunction'
            Resource: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:AthenaQueryLambda-${Alias}-${AWS::Region}-${AWS::AccountId}'

  AthenaQueryLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub 'AthenaQueryLambda-${Alias}-${AWS::Region}-${AWS::AccountId}'
      Handler: index.lambda_handler
      Role: !GetAtt AthenaQueryLambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 1024
      Timeout: 120
      #ReservedConcurrentExecutions: 2  # Set to your desired number
      Environment:
        Variables:
          S3Output: !Sub "s3://sl-athena-output-${Alias}-${AWS::AccountId}-${AWS::Region}/"
          DatabaseName: !Sub "${AliasDb}_${AthenaDatabaseName}"
      Code:
        ZipFile: |
          import boto3
          from time import sleep
          import os
          import logging

          # Initialize the Athena client
          athena_client = boto3.client('athena')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"Received event: {event}")

              def athena_query_handler(event):
                  try:
                      # Extracting the SQL query
                      query = event['requestBody']['content']['application/json']['properties'][0]['value']
                      
                      # Handle empty query (e.g., when user just says "Hi")
                      if not query or query.strip() == '':
                          logger.info("Empty query received - returning friendly message")
                          return {
                              'ResultSet': {
                                  'Rows': [
                                      {'Data': [{'VarCharValue': 'Hello! I can help you query the database. Try asking something like: "How many records are there?" or "Show me 5 incident reports"'}]}
                                  ]
                              }
                          }
                      
                      logger.info(f"Executing query: {query}")

                      s3_output = os.environ.get('S3Output')
                      if not s3_output:
                          raise Exception("S3Output environment variable is not set")

                      # Execute the query and wait for completion
                      execution_id = execute_athena_query(query, s3_output)
                      result = get_query_results(execution_id)

                      return result

                  except Exception as e:
                      logger.error(f"Error in athena_query_handler: {str(e)}")
                      raise

              def execute_athena_query(query, s3_output):
                  try:
                      database_name = os.environ.get('DatabaseName')
                      query_execution_params = {
                          'QueryString': query,
                          'ResultConfiguration': {'OutputLocation': s3_output}
                      }
                      
                      # Add QueryExecutionContext if database name is set
                      if database_name:
                          query_execution_params['QueryExecutionContext'] = {'Database': database_name}
                          logger.info(f"Using database: {database_name}")
                      
                      response = athena_client.start_query_execution(**query_execution_params)
                      return response['QueryExecutionId']
                  except Exception as e:
                      logger.error(f"Failed to start query execution: {str(e)}")
                      raise

              def check_query_status(execution_id):
                  try:
                      response = athena_client.get_query_execution(QueryExecutionId=execution_id)
                      return response['QueryExecution']['Status']['State']
                  except Exception as e:
                      logger.error(f"Failed to check query status: {str(e)}")
                      raise

              def get_query_results(execution_id):
                  try:
                      while True:
                          status = check_query_status(execution_id)
                          if status in ['SUCCEEDED', 'FAILED', 'CANCELLED']:
                              break
                          sleep(1)  # Polling interval

                      if status == 'SUCCEEDED':
                          return athena_client.get_query_results(QueryExecutionId=execution_id)
                      else:
                          logger.error(f"Query failed with status '{status}'")
                          raise Exception(f"Query failed with status '{status}'")
                  except Exception as e:
                      logger.error(f"Failed to get query results: {str(e)}")
                      raise

              try:
                  action_group = event.get('actionGroup')
                  api_path = event.get('apiPath')

                  logger.info(f"api_path: {api_path}")

                  result = ''
                  response_code = 200

                  if api_path == '/athenaQuery':
                      result = athena_query_handler(event)
                  else:
                      response_code = 404
                      result = {"error": f"Unrecognized api path: {action_group}::{api_path}"}

                  response_body = {
                      'application/json': {
                          'body': result
                      }
                  }

                  action_response = {
                      'actionGroup': action_group,
                      'apiPath': api_path,
                      'httpMethod': event.get('httpMethod'),
                      'httpStatusCode': response_code,
                      'responseBody': response_body
                  }

                  api_response = {'messageVersion': '1.0', 'response': action_response}
                  return api_response

              except Exception as e:
                  logger.error(f"Unhandled exception: {str(e)}")
                  raise

  LambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: AthenaQueryLambda
    Properties:
      FunctionName: !GetAtt AthenaQueryLambda.Arn
      Action: 'lambda:InvokeFunction'
      Principal: 'bedrock.amazonaws.com'
      SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'

  BedrockAgent:
    Type: "AWS::Bedrock::Agent"
    DependsOn: LambdaInvokePermission
    Properties:
      AgentName: !Sub 'AthenaAgent-${Alias}-${AWS::Region}-${AWS::AccountId}'
      AgentResourceRoleArn: !GetAtt BedrockAgentExecutionRole.Arn
      AutoPrepare: 'True'
      FoundationModel: !Ref FoundationModel
      Instruction: |
        # Enhanced Text-to-SQL System Prompt for EMIR Trade Repository Data
        
        ## Your Role
        You are an expert SQL analyst that creates and EXECUTES queries for Amazon Athena. You help users retrieve EMIR (European Market Infrastructure Regulation) derivatives trade data by understanding their natural language questions and converting them into accurate SQL queries.
        
        ---
        
        ## DATABASE SCHEMA
        
        **Database:** `txt2sql_dev_athena_db`
        
        ### Table: test_population (7,867 rows)
        Primary table containing EMIR trade repository data for derivatives transactions.
        
        **Key Identifiers:**
        - `incident_code`: VARCHAR - Incident/error code if any
        - `uti_2_1`: VARCHAR - Unique Transaction Identifier (UTI)
        - `isin_2_7`: VARCHAR - ISIN code for the instrument
        
        **Date Columns (CRITICAL - Use these for date queries):**
        - `reporting_date_1_1`: STRING - **Primary date field** - When the trade was reported
        - `execution_date_2_42`: STRING - When the trade was executed
        - `effective_date_2_43`: STRING - Contract effective date
        - `expiration_date_2_44`: STRING - Contract expiration date
        - `valuation_date_2_23`: STRING - Valuation date
        
        **Financial Information:**
        - `valuation_amount_2_21`: STRING - Valuation amount
        - `valuation_currency_2_22`: VARCHAR - Currency of valuation
        - `asset_class_2_11`: VARCHAR - Asset class (e.g., Interest Rate, FX, Commodity)
        
        **Note:** The table has 200+ columns total. All columns are stored as STRING type.
        
        ---
        
        ## DECISION LOGIC
        
        **DO NOT QUERY - Just respond conversationally:**
        - Greetings: "Hi", "Hello", "Hey"
        - Thank you messages
        - Questions about capabilities
        
        **ALWAYS QUERY - Call athenaQuery function:**
        - Any data request: "Show me...", "How many...", "What is..."
        - Statistical questions: "Average", "Total", "Count"
        - Date range questions: "What dates...", "Between when..."
        
        ---
        
        ## DATE HANDLING - CRITICAL
        
        **When user asks about "dates" or "date ranges" without specifics, use `reporting_date_1_1`:**
        
        ```sql
        SELECT 
            MIN(reporting_date_1_1) as earliest_date,
            MAX(reporting_date_1_1) as latest_date
        FROM test_population
        WHERE reporting_date_1_1 IS NOT NULL AND reporting_date_1_1 != '';
        ```
        
        **Date Column Selection:**
        - "reporting dates" → `reporting_date_1_1`
        - "execution dates" → `execution_date_2_42`
        - "valuation dates" → `valuation_date_2_23`
        - "when trades happened" → `execution_date_2_42`
        
        ---
        
        ## SQL GENERATION RULES
        
        1. **NEVER use placeholder names** like `your_table_name`, `date`
        2. **ALWAYS use actual table names**: test_population, txt2sql_dev_customers, txt2sql_dev_procedures
        3. **SELECT specific columns** - avoid `SELECT *` on test_population (200+ columns)
        4. **Filter NULL values**: `WHERE column IS NOT NULL AND column != ''`
        5. **All dates are STRINGs** - handle accordingly
        6. **Use LIMIT** for large result sets (default: 10-20 rows)
        
        ---
        
        ## EXAMPLE QUERIES
        
        **Q: "How many trades?"**
        ```sql
        SELECT COUNT(*) as total_trades FROM test_population;
        ```
        
        **Q: "What are the date ranges?"**
        ```sql
        SELECT 
            MIN(reporting_date_1_1) as earliest_date,
            MAX(reporting_date_1_1) as latest_date,
            COUNT(DISTINCT reporting_date_1_1) as unique_dates
        FROM test_population
        WHERE reporting_date_1_1 IS NOT NULL AND reporting_date_1_1 != '';
        ```
        
        **Q: "Show me 5 trades"**
        ```sql
        SELECT 
            uti_2_1,
            reporting_date_1_1,
            asset_class_2_11,
            valuation_amount_2_21,
            valuation_currency_2_22
        FROM test_population 
        LIMIT 5;
        ```
        
        **Q: "Trades by asset class"**
        ```sql
        SELECT 
            asset_class_2_11,
            COUNT(*) as trade_count
        FROM test_population
        WHERE asset_class_2_11 IS NOT NULL
        GROUP BY asset_class_2_11
        ORDER BY trade_count DESC;
        ```
        
        ---
        
        ## ERROR PREVENTION
        
        Before calling athenaQuery:
        - ✓ Table name is from actual schema
        - ✓ Column names are exact (reporting_date_1_1, NOT date)
        - ✓ Not using SELECT * on test_population
        - ✓ Filtering NULL/empty values
        - ✓ Using LIMIT for large results
        
        **Common Errors to Avoid:**
        - ❌ Using `date` instead of `reporting_date_1_1`
        - ❌ Using `your_table_name` or placeholders
        - ❌ SELECT * on test_population
        - ❌ Not filtering NULL values
        
        ---
        
        ## RESPONSE FORMAT
        
        Provide brief summary, then present data clearly:
        
        "I found the date range in the EMIR data:
        - Earliest: 2023-01-15
        - Latest: 2024-11-14
        - Span: 669 days"
        
        ---
        
        ## GREETING RESPONSE
        
        "Hello! I can help you analyze EMIR derivatives trade data.
        
        Try asking:
        - 'How many trades are in the database?'
        - 'What are the date ranges?'
        - 'Show me 10 trade records'
        - 'What asset classes are represented?'"
      ActionGroups:
        - ActionGroupName: query-athena
          ActionGroupExecutor:
            Lambda: !GetAtt AthenaQueryLambda.Arn
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.1",
                "info": {
                  "title": "AthenaQuery API",
                  "description": "API for querying txt2sql_dev_athena_db database. Available tables: test_population (7867 EMIR financial records), txt2sql_dev_customers, txt2sql_dev_procedures. ALWAYS use these exact table names.",
                  "version": "1.0.0"
                },
                "paths": {
                  "/athenaQuery": {
                    "post": {
                      "operationId": "POST_athenaQuery",
                      "description": "Execute a SQL query on the Athena database. Use real table names: test_population, txt2sql_dev_customers, txt2sql_dev_procedures. NEVER use placeholder names like 'your_table_name' or 'table_name'.",
                      "requestBody": {
                        "description": "SQL query to execute on txt2sql_dev_athena_db database",
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "Query": {
                                  "type": "string",
                                  "description": "SQL query using real table names (test_population, txt2sql_dev_customers, txt2sql_dev_procedures). Example: SELECT COUNT(*) FROM test_population"
                                }
                              }
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response with query results",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "ResultSet": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "description": "A single row of query results"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

  BedrockAgentAlias:
    Type: 'AWS::Bedrock::AgentAlias'
    DependsOn: BedrockAgent
    Properties:
      AgentAliasName: !Sub '${Alias}-${AWS::Region}-alias'
      AgentId: !GetAtt BedrockAgent.AgentId

Outputs:
  BedrockAgentName:
    Description: 'Name of the Bedrock Agent created'
    Value: !Ref BedrockAgent
  AgentId:
    Description: 'ID of the Bedrock Agent'
    Value: !Ref BedrockAgent
  AgentAliasId:
    Description: 'ID of the Bedrock Agent Alias'
    Value: !Select [1, !Split ["|", !Ref BedrockAgentAlias]]
  AthenaQueryLambdaArn:
    Description: 'ARN of the Athena Query Lambda function'
    Value: !GetAtt AthenaQueryLambda.Arn